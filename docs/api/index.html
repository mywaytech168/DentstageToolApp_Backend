<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dentstage Tool App API Docs</title>
    <style>
        :root {
            color-scheme: light dark;
            --primary-color: #1668c1;
            --text-color: #1f2933;
            --border-color: #d2d6dc;
            --bg-color: #f9fbff;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: "Microsoft JhengHei", "PingFang TC", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background: var(--bg-color);
            line-height: 1.6;
        }

        header {
            background: white;
            border-bottom: 1px solid var(--border-color);
            padding: 24px;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        header h1 {
            margin: 0 0 8px 0;
            font-size: 28px;
        }

        header p {
            margin: 0;
            max-width: 820px;
        }

        main {
            max-width: 1024px;
            margin: 0 auto;
            padding: 24px;
        }

        .card {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 10px 30px rgba(0, 34, 77, 0.05);
        }

        .card h2 {
            margin-top: 0;
        }

        .tag-section {
            margin-bottom: 32px;
        }

        .tag-section h3 {
            margin-bottom: 12px;
            color: var(--primary-color);
        }

        .operation-list {
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
        }

        .operation-list table {
            width: 100%;
            border-collapse: collapse;
        }

        .operation-list th,
        .operation-list td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: top;
        }

        .operation-list tr:last-child td {
            border-bottom: none;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            padding: 4px 8px;
            border-radius: 999px;
            color: white;
        }

        .badge.get { background: #15803d; }
        .badge.post { background: #1d4ed8; }
        .badge.put { background: #b45309; }
        .badge.delete { background: #b91c1c; }
        .badge.patch { background: #6b21a8; }

        a {
            color: var(--primary-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        code {
            background: #eef2ff;
            border-radius: 6px;
            padding: 2px 6px;
            font-family: "JetBrains Mono", "Cascadia Code", Consolas, "Liberation Mono", monospace;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            margin-bottom: 16px;
            color: #475569;
            font-weight: 600;
        }

        .section-title {
            font-size: 20px;
            margin-bottom: 12px;
        }

        table.schema-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 16px;
        }

        table.schema-table th,
        table.schema-table td {
            padding: 10px 12px;
            border: 1px solid var(--border-color);
        }

        table.schema-table th {
            background: #f3f4f6;
        }

        .empty-state {
            padding: 16px;
            border-radius: 8px;
            background: #f9fafb;
            border: 1px dashed var(--border-color);
            color: #6b7280;
        }

        footer {
            padding: 24px;
            text-align: center;
            color: #6b7280;
        }

        @media (max-width: 768px) {
            header, main {
                padding: 16px;
            }

            .card {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
<header>
    <h1>Dentstage Tool App API Docs</h1>
    <p>
        本文件依據 Swagger 規格即時產生，提供每支 API 的請求欄位、回應格式與錯誤代碼總覽。
        透過右上角的「外部文件」按鈕即可從 Swagger 跳轉到對應頁面。
    </p>
</header>
<main>
    <div id="loading" class="card">
        讀取 Swagger 規格中，請稍候...
    </div>
    <div id="content" hidden></div>
</main>
<footer>
    Dentstage Tool App 後端文件中心 · 由 Swagger 自動匯出 · 更新時間 <span id="generated-at"></span>
</footer>
<script>
    // 以 IIFE 形式包裝主流程，避免汙染全域命名空間。
    (async () => {
        const loadingElement = document.getElementById("loading");
        const contentElement = document.getElementById("content");
        const generatedAtElement = document.getElementById("generated-at");
        try {
            const spec = await fetchSwaggerSpec();
            renderPage(spec, loadingElement, contentElement);
            generatedAtElement.textContent = new Date().toLocaleString("zh-TW", { hour12: false });
        } catch (error) {
            loadingElement.textContent = `載入 Swagger 規格失敗：${error.message}`;
            loadingElement.classList.add("empty-state");
        }
    })();

    /**
     * 嘗試從 API 或本地備援檔案載入 Swagger JSON。
     * 先呼叫 API，失敗後改用專案內的離線檔案以降低網路依賴。
     */
    async function fetchSwaggerSpec() {
        const candidates = [];
        const origin = window.location.origin && window.location.origin !== "null"
            ? window.location.origin
            : "";
        if (origin) {
            candidates.push(`${origin}/swagger/v1/swagger.json`);
        }
        candidates.push(new URL("../swagger/dentstage-tool-app-api-v1.json", window.location.href).href);

        for (const url of candidates) {
            try {
                const response = await fetch(url, { cache: "no-store" });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                // 成功取得規格後直接回傳 JSON。
                return await response.json();
            } catch (error) {
                console.warn(`載入 Swagger 規格失敗：${url}`, error);
            }
        }

        throw new Error("無法取得 Swagger 規格，請確認服務是否已啟動。");
    }

    /**
     * 依據 URL 參數判斷顯示列表或單一 API 詳細資訊。
     */
    function renderPage(spec, loadingElement, contentElement) {
        const params = new URLSearchParams(window.location.search);
        const operationId = params.get("operationId");

        loadingElement.hidden = true;
        contentElement.hidden = false;
        contentElement.innerHTML = "";

        if (operationId) {
            renderOperationDetail(spec, operationId, contentElement);
        } else {
            renderOperationList(spec, contentElement);
        }
    }

    /**
     * 產生所有 API 的列表畫面，依 Tag 分組顯示摘要資訊。
     */
    function renderOperationList(spec, container) {
        const operations = collectOperations(spec);
        if (!operations.length) {
            container.appendChild(createEmptyState("Swagger 中沒有可用的 API 定義。"));
            return;
        }

        const introCard = document.createElement("section");
        introCard.className = "card";
        introCard.innerHTML = `
            <h2>如何使用</h2>
            <p>點擊任一列即可查看完整的參數說明、範例與回應結構。右方的 Swagger 連結會直接導向互動式測試畫面。</p>
        `;
        container.appendChild(introCard);

        const grouped = groupByTag(operations);
        grouped.forEach(group => {
            const section = document.createElement("section");
            section.className = "tag-section";
            section.innerHTML = `<h3>${group.tag}</h3>`;

            const listWrapper = document.createElement("div");
            listWrapper.className = "operation-list";
            const table = document.createElement("table");
            table.innerHTML = `
                <thead>
                    <tr>
                        <th style="width: 120px;">方法</th>
                        <th style="width: 260px;">路徑</th>
                        <th>摘要</th>
                        <th style="width: 120px;">詳細說明</th>
                    </tr>
                </thead>
                <tbody></tbody>
            `;

            group.operations.forEach(operation => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td><span class="badge ${operation.method.toLowerCase()}">${operation.method}</span></td>
                    <td><code>${operation.path}</code></td>
                    <td>
                        <div><strong>${operation.summary || operation.operationId}</strong></div>
                        <div>${operation.description || "尚未撰寫補充說明"}</div>
                    </td>
                    <td>
                        <a href="?operationId=${encodeURIComponent(operation.operationId)}">DOCS</a>
                        <span aria-hidden="true"> · </span>
                        <a href="${operation.swaggerUiLink}" target="_blank" rel="noopener">Swagger</a>
                    </td>
                `;
                table.querySelector("tbody").appendChild(row);
            });

            listWrapper.appendChild(table);
            section.appendChild(listWrapper);
            container.appendChild(section);
        });
    }

    /**
     * 顯示單一 API 的完整說明，包含參數、Request Body 與回應結構。
     */
    function renderOperationDetail(spec, operationId, container) {
        const operationInfo = findOperationById(spec, operationId);
        if (!operationInfo) {
            container.appendChild(createEmptyState(`找不到 OperationId 為 ${operationId} 的定義。`));
            return;
        }

        const { path, method, operation } = operationInfo;

        const backLink = document.createElement("a");
        backLink.className = "back-link";
        backLink.href = "./index.html";
        backLink.textContent = "← 回到 API 總覽";
        container.appendChild(backLink);

        const summaryCard = document.createElement("section");
        summaryCard.className = "card";
        summaryCard.innerHTML = `
            <h2>${operation.summary || operation.operationId}</h2>
            <p>${operation.description || "尚未撰寫補充說明。"}</p>
            <ul>
                <li><strong>HTTP 方法：</strong> <span class="badge ${method.toLowerCase()}">${method}</span></li>
                <li><strong>路徑：</strong> <code>${path}</code></li>
                <li><strong>OperationId：</strong> ${operation.operationId}</li>
                <li><strong>分類：</strong> ${(operation.tags || ["未指定"]).join(", ")}</li>
            </ul>
            <p>
                <a href="${buildSwaggerUiLink(operation.operationId, operation.tags && operation.tags[0])}" target="_blank" rel="noopener">在 Swagger 中測試</a>
            </p>
        `;
        container.appendChild(summaryCard);

        container.appendChild(renderParametersSection(operation, spec));
        container.appendChild(renderRequestBodySection(operation, spec));
        container.appendChild(renderResponsesSection(operation, spec));
    }

    /**
     * 產生參數清單表格，整合路徑參數與查詢參數。
     */
    function renderParametersSection(operation, spec) {
        const section = document.createElement("section");
        section.className = "card";
        section.innerHTML = `<h3 class="section-title">請求參數</h3>`;

        if (!operation.parameters || operation.parameters.length === 0) {
            section.appendChild(createEmptyState("此 API 無額外的路徑或查詢參數。"));
            return section;
        }

        const table = document.createElement("table");
        table.className = "schema-table";
        table.innerHTML = `
            <thead>
                <tr>
                    <th>名稱</th>
                    <th>位置</th>
                    <th>必填</th>
                    <th>資料型別</th>
                    <th>說明</th>
                </tr>
            </thead>
            <tbody></tbody>
        `;

        operation.parameters.forEach(parameter => {
            const row = document.createElement("tr");
            row.innerHTML = `
                <td>${parameter.name}</td>
                <td>${parameter.in}</td>
                <td>${parameter.required ? "是" : "否"}</td>
                <td>${describeSchemaType(parameter.schema, spec)}</td>
                <td>${parameter.description || "--"}</td>
            `;
            table.querySelector("tbody").appendChild(row);
        });

        section.appendChild(table);
        return section;
    }

    /**
     * 產生 Request Body 說明，逐一列出 Content-Type 與欄位結構。
     */
    function renderRequestBodySection(operation, spec) {
        const section = document.createElement("section");
        section.className = "card";
        section.innerHTML = `<h3 class="section-title">Request Body</h3>`;

        if (!operation.requestBody) {
            section.appendChild(createEmptyState("此 API 無需傳遞 Request Body。"));
            return section;
        }

        const requestBody = operation.requestBody;
        const description = document.createElement("p");
        description.textContent = requestBody.description || "請參考下方欄位結構。";
        section.appendChild(description);

        Object.entries(requestBody.content || {}).forEach(([contentType, contentValue]) => {
            const block = document.createElement("div");
            block.innerHTML = `<h4>${contentType}</h4>`;
            block.appendChild(renderSchemaDetails(contentValue.schema, spec));
            section.appendChild(block);
        });

        return section;
    }

    /**
     * 顯示 Response 定義，包含狀態碼與對應的資料型別。
     */
    function renderResponsesSection(operation, spec) {
        const section = document.createElement("section");
        section.className = "card";
        section.innerHTML = `<h3 class="section-title">回應格式</h3>`;

        const responses = operation.responses || {};
        const statusCodes = Object.keys(responses);
        if (!statusCodes.length) {
            section.appendChild(createEmptyState("Swagger 未定義任何回應格式。"));
            return section;
        }

        statusCodes.forEach(statusCode => {
            const response = responses[statusCode];
            const block = document.createElement("div");
            block.innerHTML = `<h4>HTTP ${statusCode}</h4><p>${response.description || "--"}</p>`;

            if (response.content) {
                Object.entries(response.content).forEach(([contentType, contentValue]) => {
                    const schemaBlock = document.createElement("div");
                    schemaBlock.innerHTML = `<h5>${contentType}</h5>`;
                    schemaBlock.appendChild(renderSchemaDetails(contentValue.schema, spec));
                    block.appendChild(schemaBlock);
                });
            }

            section.appendChild(block);
        });

        return section;
    }

    /**
     * 蒐集所有 Operation 的摘要資訊，後續可依 Tag 分組使用。
     */
    function collectOperations(spec) {
        const operations = [];
        if (!spec.paths) {
            return operations;
        }

        Object.entries(spec.paths).forEach(([path, methods]) => {
            Object.entries(methods).forEach(([method, operation]) => {
                const ensuredId = ensureOperationId(path, method, operation);
                if (!operation || !ensuredId) {
                    return;
                }
                operations.push({
                    path,
                    method: method.toUpperCase(),
                    operationId: ensuredId,
                    summary: operation.summary,
                    description: operation.description,
                    tags: operation.tags && operation.tags.length ? operation.tags : ["未指定"],
                    swaggerUiLink: buildSwaggerUiLink(ensuredId, operation.tags && operation.tags[0])
                });
            });
        });

        return operations.sort((a, b) => a.path.localeCompare(b.path));
    }

    /**
     * 依據 Swagger 標籤分組，維持原本的先後順序。
     */
    function groupByTag(operations) {
        const map = new Map();
        operations.forEach(operation => {
            operation.tags.forEach(tag => {
                if (!map.has(tag)) {
                    map.set(tag, []);
                }
                map.get(tag).push(operation);
            });
        });

        return Array.from(map.entries()).map(([tag, ops]) => ({ tag, operations: ops }));
    }

    /**
     * 由 OperationId 往回查找對應的路徑與方法。
     */
    function findOperationById(spec, operationId) {
        if (!spec.paths) {
            return null;
        }

        for (const [path, methods] of Object.entries(spec.paths)) {
            for (const [method, operation] of Object.entries(methods)) {
                const ensuredId = ensureOperationId(path, method, operation);
                if (operation && ensuredId === operationId) {
                    return {
                        path,
                        method: method.toUpperCase(),
                        operation: { ...operation, operationId: ensuredId }
                    };
                }
            }
        }

        return null;
    }

    /**
     * 建立 Swagger UI 的直接連結，方便快速測試 API。
     */
    function buildSwaggerUiLink(operationId, tag) {
        const origin = window.location.origin && window.location.origin !== "null"
            ? window.location.origin
            : "";
        const baseUrl = origin ? `${origin}/swagger/index.html` : "/swagger/index.html";
        if (!operationId) {
            return baseUrl;
        }

        // Swagger UI 的錨點組成為 #/分類/OperationId，缺少分類時改用 default 維持定位。
        const anchorTag = tag && typeof tag === "string" && tag.trim() ? encodeURIComponent(tag) : "default";
        return `${baseUrl}#/${anchorTag}/${encodeURIComponent(operationId)}`;
    }

    /**
     * 確保 Swagger Operation 擁有 operationId，缺漏時以方法與路徑組成備援識別碼。
     */
    function ensureOperationId(path, method, operation) {
        if (!operation) {
            return null;
        }

        if (operation.operationId && operation.operationId.trim()) {
            return operation.operationId;
        }

        if (!path || !method) {
            return null;
        }

        // 移除查詢與大括號後改以底線銜接，避免出現無法作為錨點的符號。
        const sanitizedPath = path
            .split(/[?#]/)[0]
            .replace(/[{}]/g, "")
            .replace(/[^a-zA-Z0-9]+/g, "_")
            .replace(/^_+|_+$/g, "");

        const baseId = sanitizedPath ? `${method.toUpperCase()}_${sanitizedPath}` : method.toUpperCase();
        const fallbackId = baseId.replace(/_+/g, "_");
        if (!fallbackId.trim()) {
            return null;
        }

        // 將結果同步回原本物件，讓後續渲染步驟可以直接使用。
        operation.operationId = fallbackId;
        return fallbackId;
    }

    /**
     * 將 schema 的型別轉換成人類易懂的文字描述。
     */
    function describeSchemaType(schema, spec) {
        if (!schema) {
            return "未定義";
        }
        if (schema.$ref) {
            return extractRefName(schema.$ref);
        }
        if (schema.type === "array") {
            return `Array<${describeSchemaType(schema.items, spec)}>`;
        }
        return schema.format ? `${schema.type} (${schema.format})` : schema.type || "未指定";
    }

    /**
     * 輔助解析 $ref 名稱，僅保留最後一段名稱供顯示使用。
     */
    function extractRefName(ref) {
        return ref.split("/").pop();
    }

    /**
     * 將 Schema 詳細資訊轉為 HTML，包含欄位、型別與說明。
     */
    function renderSchemaDetails(schema, spec, visited = new Set()) {
        if (!schema) {
            return createEmptyState("未提供資料結構定義。");
        }

        const resolved = resolveSchema(schema, spec);
        if (!resolved) {
            return createEmptyState("找不到對應的 schema 定義。");
        }

        const { target, refName } = resolved;
        const block = document.createElement("div");
        block.className = "schema-block";

        if (refName) {
            const title = document.createElement("h5");
            title.textContent = refName;
            block.appendChild(title);
        }

        if (target.description) {
            const desc = document.createElement("p");
            desc.textContent = target.description;
            block.appendChild(desc);
        }

        if (refName && visited.has(refName)) {
            // 為避免循環參考造成無限遞迴，此處偵測到重複引用時直接輸出提醒。
            block.appendChild(createEmptyState("為避免循環參考，已略過重複的結構。"));
            return block;
        }

        if (refName) {
            visited.add(refName);
        }

        if (Array.isArray(target.allOf) && target.allOf.length) {
            const list = document.createElement("div");
            list.innerHTML = "<p>此結構由下列組成 (allOf)：</p>";
            target.allOf.forEach(part => {
                list.appendChild(renderSchemaDetails(part, spec, new Set(visited)));
            });
            block.appendChild(list);
            return block;
        }

        if (Array.isArray(target.oneOf) && target.oneOf.length) {
            const list = document.createElement("ol");
            list.start = 1;
            target.oneOf.forEach(part => {
                const item = document.createElement("li");
                item.appendChild(renderSchemaDetails(part, spec, new Set(visited)));
                list.appendChild(item);
            });
            block.appendChild(document.createTextNode("以下任選其一結構："));
            block.appendChild(list);
            return block;
        }

        if (Array.isArray(target.anyOf) && target.anyOf.length) {
            const list = document.createElement("ul");
            target.anyOf.forEach(part => {
                const item = document.createElement("li");
                item.appendChild(renderSchemaDetails(part, spec, new Set(visited)));
                list.appendChild(item);
            });
            block.appendChild(document.createTextNode("可使用下列任一結構："));
            block.appendChild(list);
            return block;
        }

        if (target.type === "object" || target.properties) {
            const table = document.createElement("table");
            table.className = "schema-table";
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>欄位</th>
                        <th>型別</th>
                        <th>必填</th>
                        <th>說明</th>
                    </tr>
                </thead>
                <tbody></tbody>
            `;

            const requiredFields = new Set(target.required || []);
            Object.entries(target.properties || {}).forEach(([propertyName, propertySchema]) => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td>${propertyName}</td>
                    <td>${describeSchemaType(propertySchema, spec)}</td>
                    <td>${requiredFields.has(propertyName) ? "是" : "否"}</td>
                    <td>${propertySchema.description || "--"}</td>
                `;
                table.querySelector("tbody").appendChild(row);
            });

            block.appendChild(table);
        } else if (target.type === "array" && target.items) {
            const paragraph = document.createElement("p");
            paragraph.textContent = `陣列項目型別：${describeSchemaType(target.items, spec)}`;
            block.appendChild(paragraph);
            block.appendChild(renderSchemaDetails(target.items, spec, visited));
        } else {
            const paragraph = document.createElement("p");
            paragraph.textContent = `資料型別：${describeSchemaType(target, spec)}`;
            block.appendChild(paragraph);
        }

        if (target.example) {
            const example = document.createElement("pre");
            example.textContent = JSON.stringify(target.example, null, 2);
            block.appendChild(example);
        }

        if (target.enum) {
            const enumBlock = document.createElement("p");
            enumBlock.textContent = `可用值：${target.enum.join(", ")}`;
            block.appendChild(enumBlock);
        }

        return block;
    }

    /**
     * 將 $ref 解析成實際的 Schema 物件。
     */
    function resolveSchema(schema, spec) {
        if (schema.$ref) {
            const refName = extractRefName(schema.$ref);
            const target = spec.components && spec.components.schemas
                ? spec.components.schemas[refName]
                : null;
            if (!target) {
                return null;
            }
            return { target, refName };
        }
        return { target: schema, refName: null };
    }

    /**
     * 建立統一的空狀態提示元素。
     */
    function createEmptyState(message) {
        const wrapper = document.createElement("div");
        wrapper.className = "empty-state";
        wrapper.textContent = message;
        return wrapper;
    }
</script>
</body>
</html>
